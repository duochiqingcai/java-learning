1.底层的存储结构
    与数组不同（数组是一块连续的内存空间）；链表不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来。

2.链表结构：单链表、双向链表、循环链表
    a.单链表
        每一个内存块称为链表的“结点”-node，node存储数据和下一个结点的地址(data+next)，记录下一个node地址的指针叫做后继指针next。从单链表图中看出，有
    两个节点比较特殊，分别是链表的第一个node和最后一个node，叫做头结点和尾结点，其中头结点记录链表的基地址，因此可以遍历整条链表；尾结点的next指针不是
    指向下一个结点，而是指向一个空地址NULL，表示链表的最后一个结点。

        链表的查找、插入和删除：
        数组的插入和删除操作，因其内存连续性，所以时间复杂度为O(n)；而链表的数据插入和删除，因为内存存储空间不连续，只需要相邻结点node的指针改变，
    所以速度快，时间复杂度为O(1)。但也因此，链表的随机访问速度慢，时间复杂度为O(n)，无法通过首地址和下标快速查询，而需要根据指针一个一个结点遍历。

    b.循环链表 (一种特殊的单链表)
        循环链表和单链表区别在于尾结点，单链表指针指向NULL，循环链表指向头结点。像一个环。
        当处理的数据具有环形结构特点时，使用循环链表。

    c.双链表
        双链表和单链表不同的是有两个方向，每个结点node不止有一个后继指针next指向后面的结点，还有一个前驱指针指prev向前面的结点；双向链表还需要额外的
    两个空间存储prev和next的地址，所以存储相同数据，需要占用更多空间，但是支持双向遍历，操作更灵活。

        双向链表删除操作：(两种情况)
        a.删除结点中“值等于给定值”的结点
            需要先遍历查找到该数据(时间复杂度O(n))，然后进行删除(时间复杂度O(1)),根据加法法则，总时间复杂度为O(n)；
        b.删除给定指针指向的结点
            这种情况已经找到要删除的结点，要删除该结点q，需要知道起前驱结点，双向链表保存有前驱结点的地址，而不需要像单向链表那样遍历，所以，对于
        单向链表删除需要O(n)，双向链表只需要O(1)；

        双向链表插入操作：和删除情况类似，可以在O(1)完成。

    所以，LinkedList和LinkedHashMap容器内部用到双向链表。


    链表是空间换时间的设计思想。

3.编写链表代码的技巧
    a.理解指针或者引用的含义
        将某个变量赋值给指针的意思，实际上是指将这个变量的内存地址赋值给指针，或者说，指针中存储的变量的内存地址，实际上指向这个变量，通过指针的内存地址
    就能找到这个变量；
        例如：p->next=q，这行代码是说，p结点中的 next 指针存储了q结点的内存地址；
             p->next=p->next->next,指p结点的next指针存储了p结点的下下个结点的内存地址；

    b.警惕指针丢失和内存泄漏
        1.单链表插入结点
            new_node->next = p->next;
            p->next = new_node;

            如果向空链表中插入第一个结点，和其他不一样：
            head表示链表的头结点，
            if (head == null) {
                head = new_node;
            }

        2.单链表删除p结点的下一个结点
            p->next = p->next->next;

            如果要删除链表的最后一个结点：
            if (head->next == null) {
                head = null;
            }
        删除链表结点时，也一定要记得手动释放内存空间,否则会发生内存泄漏，但是对于java具有自动内存管理，可以不管。

        针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点情况进行特殊处理。

    c.利用哨兵简化链表操作实现难度
        1.什么是哨兵？
        空链表：head=null 表示链表中没有结点了。其中 head 表示头结点指针，指向链表中的第一个结点。如果我们引入哨兵结点，在任何时候，
        不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

        2.未引用哨兵时
            a.单链表插入结点
                        new_node->next = p->next;
                        p->next = new_node;

                        如果向空链表中插入第一个结点，和其他不一样：
                        head表示链表的头结点，
                        if (head == null) {
                            head = new_node;
                        }
            b.单链表删除p结点的下一个结点
                        p->next = p->next->next;

                        如果要删除链表的最后一个结点：
                        if (head->next == null) {
                            head = null;
                        }

        3.引入哨兵时
            “哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，
            删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

    d.重点留意边界条件处理
        经常用来检查链表是否正确的边界4个边界条件：
        1.如果链表为空时，代码是否能正常工作？
        2.如果链表只包含一个节点时，代码是否能正常工作？
        3.如果链表只包含两个节点时，代码是否能正常工作？
        4.代码逻辑在处理头尾节点时是否能正常工作？

    e.举例画图，辅助思考
        核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

    f.多写多练，没有捷径
        5个常见的链表操作：
        1.单链表反转
        2.链表中环的检测
        3.两个有序链表合并
        4.删除链表倒数第n个节点
        5.求链表的中间节点









