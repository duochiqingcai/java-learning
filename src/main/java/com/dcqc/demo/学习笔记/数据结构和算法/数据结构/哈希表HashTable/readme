散列表Hash Table，也叫“哈希表”或“Hash表”。（现在用的很少）
    散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然将数据存储在数组中对应下标
的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

1.散列思想
    散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

2.散列函数
    通俗讲，hash函数通过一系列算法得到一个hash值。
    散列函数，它是一个函数。我们可以把它定义成hash(key)，其中 key 表示元素的键值（也可以理解为输入），hash(key)的值表示经过散列函数计算
得到的散列值（hash值）。
    设计散列函数的三点要求：
    a.散列函数计算得到的散列值是一个非负整数;因为数组下标从0开始；
    b.如果 key1 = key2，那 hash(key1) ==hash(key2)；相同的key，散列后的值应该相同；
    c.如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)；无法避免hash冲突（hash碰撞）可能造成的输出hash值相同。

3.hash冲突（hash碰撞）的解决方法
    首先再好的散列函数也无法避免hash冲突，怎么解决hash冲突呢？常用有两个方法。

    a.开放寻址法
        开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。
        探测方法又有：线性探测、二次探测、双重散列。
    b.链表法
        链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。如图，在散列表中，每个“桶（bucket）”或者“槽（slot）”
        会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

4.HashTable特性
    a.底层数据结构
    数组
    b.线程是否安全
    线程安全
    c.时间复杂度
    同数组
    d.默认长度11，若扩容的话为2n+1


