Java多线程
多线程是为了更好的利用CPU资源，提高生产率和高效完成任务。
1.重要概念
    a.同步和异步
        同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像一个消息
    传递，一旦开始，方法调用就会立即返回，调用者可以继续后续的操作。
        关于异步目前比较经典以及常用的实现方式就是消息队列：在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据
    库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取
    数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。
    b.并发Concurrency和并行Parallelism（易混淆）
        并发指两个或多个任务在同一时间间隔发生，偏重多个任务交替执行；并行指两个或多个事件在同一时刻发生。
    c.高并发High Concurrency
        高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。
        高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等。
    d.临界区
        临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要
    想使用这个资源，就必须等待。在并行程序中，临界区资源是保护的对象。
    e.阻塞和非阻塞
        阻塞指在得到结果之前，该函数阻塞当前线程，将线程挂起，而不会立刻返回，而非阻塞与之相反。

2.使用多线程的常见方法
    a.继承Thread类（本质也是实现Runnable接口），没有返回值
        start()方法是指启动新线程运行，然后再运行run()方法。
    b.实现Runnable接口，没有返回值
        先实现接口，然后创建Thread实例对象，因为要运行start()启动新线程。
    c.使用线程池（常用方法）
        需要先配置线程池信息。

3.实例变量和线程安全
    线程类中的实例变量对于其他线程有分享和不分享的分别。
    a.不共享数据情况（线程安全）
    b.共享数据情况（线程不安全）
    解决办法：一种是利用 synchronized 关键字（保证任意时刻只能有一个线程执行该方法），一种是利用 AtomicInteger 类（JUC 中的 Atomic 原子类）。
    这里不能用volatile关键字，因为 volatile 关键字不能保证复合操作的原子性。

4.线程常用方法
    a.currentThread()
    返回对当前正在执行的线程对象的引用。

    b.getId()
    返回此线程的标识符

    c.getName()
    返回此线程的名称

    d.getPriority()
    返回此线程的优先级

    e.isAlive()
    测试这个线程是否还处于活动状态。
    什么是活动状态呢？
    活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。

    f.sleep(long millis)
    使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。

    g.interrupt()
    中断这个线程。

    h.interrupted() 和isInterrupted()
    interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能
    isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但部清楚状态标志

    i.setName(String name)
    将此线程的名称更改为等于参数 name 。

    j.isDaemon()
    测试这个线程是否是守护线程。

    k.setDaemon(boolean on)
    将此线程标记为 daemon线程或用户线程。

    l.join()
    在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，
    需要用到子线程的处理结果，也就是 主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。
    join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有
    等到子线程结束了才能执行.

    m.yield()
    yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。

    n.setPriority(int newPriority)
    更改当前线程的优先级

5.线程生命周期内的状态5个
    NEW（新建状态）、RUNNABLE（就绪状态）、RUNNING（运行状态）、BLOCKED（阻塞状态）、DEAD（终止状态）

6.停止一个线程
    stop(),suspend(),resume()（仅用于与suspend()一起使用）这些方法已被弃用.

    a.interrupt()方法




