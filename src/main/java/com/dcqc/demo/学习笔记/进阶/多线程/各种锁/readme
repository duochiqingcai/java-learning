
1.各类锁的概念
    a.公平锁/非公平锁
    非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

    对于JUC ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
    对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过 AQS 的来实现线程调度，所以并没有任何办法使其变成公平锁。

    b.可重入锁
    又名递归锁，指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁（通俗讲，当前线程在持有该锁的情况下，可以再次申请获取锁，不释放，继续持有该锁）。
    说的有点抽象，下面会有一个代码的示例。对于ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
    对于Synchronized而言,也是一个可重入锁；因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，
    也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。
    可重入锁的一个好处是可一定程度避免死锁。

    synchronized void setA() throws Exception{
        Thread.sleep(1000);//sleep不释放锁，继续持有。
        setB();
    }

    synchronized void setB() throws Exception{
        Thread.sleep(1000);
    }
    上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB 可能不会被当前线程执行，可能造成死锁。

    c.独享锁/共享锁
    独享锁是指该锁一次只能被一个线程所持有。

    共享锁是指该锁可被多个线程所持有。

    对于ReentrantLock而言，其是独享锁。但是对于 Lock 的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁
    可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过 AQS 来实现的，通过实现不同的方法，来实现独享或者共享。
    对于Synchronized而言，当然是独享锁。

    d.互斥锁/读写锁
    互斥锁在Java中具体实现为ReentrantLock,读写锁在Java中具体实现为ReadWriteLock。

    e.乐观锁/悲观锁
    乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，
    也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的
    并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

    悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在 Java 中的使用，就是利用各种锁。
    乐观锁在 Java 中的使用，是无锁编程，常常采用的是 CAS 算法，典型的例子就是原子类，通过 CAS 自旋实现原子操作的更新。

    f.分段锁
    分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
    我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为 Segment，它即类似于 HashMap（JDK7 与
    JDK8 中 HashMap 的实现）的结构，即内部拥有一个 Entry 数组，数组中的每个元素既是一个链表；同时又是一个 ReentrantLock（Segment 继承了
    ReentrantLock)。当需要 put 元素的时候，并不是对整个 hashmap 进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，
    然后对这个分段进行加锁，所以当多线程 put 的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计 size 的时候，可就是获取
    hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。
    分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

    g.偏向锁/轻量级锁/重量级锁
    锁的状态总共有四种,按照量级从轻到重分为：无锁、偏向锁、轻量级锁、重量级锁。
    这三种锁是指锁的状态，并且是针对Synchronized。在 Java 5 通过引入锁升级的机制来实现高效Synchronized。

    这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

    偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

    轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

    重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该
    锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

    h.自旋锁
    在 Java 中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会
    消耗 CPU。


2.为什么用 Lock、ReadWriteLock
    synchronized 的缺陷：
    被 synchronized 修饰的方法或代码块，只能被一个线程访问。如果这个线程被阻塞，其他线程也只能等待。
    synchronized 不能响应中断。
    synchronized 没有超时机制。
    synchronized 只能是非公平锁。

    Lock、ReadWriteLock 相较于 synchronized，解决了以上的缺陷：
    Lock 可以手动释放锁（synchronized 获取锁和释放锁都是自动的），以避免死锁。
    Lock 可以响应中断
    Lock 可以设置超时时间，避免一致等待
    Lock 可以选择公平锁或非公平锁两种模式
    ReadWriteLock 将读写锁分离，从而使读写操作分开，有效提高并发性。